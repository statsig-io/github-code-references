"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Statsig = exports.StatsigServer = exports.Layer = exports.DynamicConfig = void 0;
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
exports.DynamicConfig = DynamicConfig_1["default"];
var Errors_1 = require("./Errors");
var Layer_1 = __importDefault(require("./Layer"));
exports.Layer = Layer_1["default"];
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var StatsigInstanceUtils_1 = __importDefault(require("./StatsigInstanceUtils"));
var StatsigServer_1 = __importDefault(require("./StatsigServer"));
exports.StatsigServer = StatsigServer_1["default"];
exports.Statsig = {
    // These need to be exported, and we currently export a top level Statsig object
    // So in order to not make a breaking change, they must be exported as members of
    // that top level object
    DynamicConfig: DynamicConfig_1["default"],
    Layer: Layer_1["default"],
    /**
     * Initializes the statsig server SDK.
     * This must be called before checking gates/configs or logging events.
     *
     * @param {string} secretKey - The secret key for this project from the statsig console. Secret keys should be kept secure on the server side, and not used for client-side integrations
     * @param {?StatsigOptions} [options={}] - manual sdk configuration for advanced setup
     * @returns {Promise<void>} - a promise which rejects only if you fail to provide a proper SDK Key
     * @throws Error if a Server Secret Key is not provided
     */
    initialize: function (secretKey, options) {
        var _a;
        if (options === void 0) { options = {}; }
        if (options.logger) {
            OutputLogger_1["default"].setLogger(options.logger);
        }
        var inst = (_a = StatsigInstanceUtils_1["default"].getInstance()) !== null && _a !== void 0 ? _a : new StatsigServer_1["default"](secretKey, options);
        if (StatsigInstanceUtils_1["default"].getInstance() == null) {
            StatsigInstanceUtils_1["default"].setInstance(inst);
        }
        return inst.initializeAsync();
    },
    /**
     * Gets the boolean result of a gate, evaluated against the given user.
     * An exposure event will automatically be logged for the gate.
     *
     * @param {StatsigUser} user - the user to check this gate value for
     * @param {string} gateName - the name of the gate to check
     * @returns {Promise<boolean>} - The value of the gate for the user.  Gates are off (return false) by default
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    checkGate: function (user, gateName) {
        return this._enforceServer().checkGate(user, gateName);
    },
    getFeatureGate: function (user, gateName) {
        return this._enforceServer().getFeatureGate(user, gateName);
    },
    /**
     * Gets the boolean result of a gate, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to check this gate value for
     * @param {string} gateName - the name of the gate to check
     * @returns {Promise<boolean>} - The value of the gate for the user.  Gates are off (return false) by default
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    checkGateWithExposureLoggingDisabled: function (user, gateName) {
        return this._enforceServer().checkGateWithExposureLoggingDisabled(user, gateName);
    },
    getFeatureGateWithExposureLoggingDisabled: function (user, gateName) {
        return this._enforceServer().getFeatureGateWithExposureLoggingDisabled(user, gateName);
    },
    /**
     * Logs an exposure event for the gate
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} gateName - the name of the gate to expose
     */
    manuallyLogGateExposure: function (user, gateName) {
        return this._enforceServer().logGateExposure(user, gateName);
    },
    /**
     * Get the values of a dynamic config, evaluated against the given user.
     * An exposure event will automatically be logged for the dynamic config.
     *
     * @param {StatsigUser} user - the user to evaluate for the dyamic config
     * @param {string} configName - the name of the dynamic config to get
     * @returns {Promise<DynamicConfig>} - the config for the user
     * @throws Error if initialize() was not called first
     * @throws Error if the configName is not provided or not a non-empty string
     */
    getConfig: function (user, configName) {
        return this._enforceServer().getConfig(user, configName);
    },
    /**
     * Get the values of a dynamic config, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to evaluate for the dyamic config
     * @param {string} configName - the name of the dynamic config to get
     * @returns {Promise<DynamicConfig>} - the config for the user
     * @throws Error if initialize() was not called first
     * @throws Error if the configName is not provided or not a non-empty string
     */
    getConfigWithExposureLoggingDisabled: function (user, configName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabled(user, configName);
    },
    /**
     * Logs an exposure event for the dynamic config
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} configName - the name of the dynamic config to expose
     */
    manuallyLogConfigExposure: function (user, configName) {
        return this._enforceServer().logConfigExposure(user, configName);
    },
    /**
     * Get the values of an experiment, evaluated against the given user.
     * An exposure event will automatically be logged for the experiment.
     *
     * @param {StatsigUser} user - the user to evaluate for the experiment
     * @param {string} experimentName - the name of the experiment to get
     * @returns {Promise<DynamicConfig>} - the experiment for the user, represented by a Dynamic Config object
     * @throws Error if initialize() was not called first
     * @throws Error if the experimentName is not provided or not a non-empty string
     */
    getExperiment: function (user, experimentName) {
        return this._enforceServer().getExperiment(user, experimentName);
    },
    /**
     * Get the values of an experiment, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to evaluate for the experiment
     * @param {string} experimentName - the name of the experiment to get
     * @returns {Promise<DynamicConfig>} - the experiment for the user, represented by a Dynamic Config object
     * @throws Error if initialize() was not called first
     * @throws Error if the experimentName is not provided or not a non-empty string
     */
    getExperimentWithExposureLoggingDisabled: function (user, experimentName) {
        return this._enforceServer().getExperimentWithExposureLoggingDisabled(user, experimentName);
    },
    /**
     * Logs an exposure event for the experiment
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} experimentName - the name of the experiment to expose
     */
    manuallyLogExperimentExposure: function (user, experimentName) {
        return this._enforceServer().logExperimentExposure(user, experimentName);
    },
    /**
     * Get the values of a layer, evaluated against the given user.
     * Exposure events will be fired when get or getValue is called on the resulting Layer class.
     *
     * @param {StatsigUser} user - the user to evaluate for the layer
     * @param {string} layerName - the name of the layer to get
     * @returns {Promise<Layer>} - the layer for the user, represented by a Layer
     * @throws Error if initialize() was not called first
     * @throws Error if the layerName is not provided or not a non-empty string
     */
    getLayer: function (user, layerName) {
        return this._enforceServer().getLayer(user, layerName);
    },
    /**
     * Get the values of a layer, evaluated against the given user.
     * No exposure events will be logged from the resulting Layer class.
     *
     * @param {StatsigUser} user - the user to evaluate for the layer
     * @param {string} layerName - the name of the layer to get
     * @returns {Promise<Layer>} - the layer for the user, represented by a Layer
     * @throws Error if initialize() was not called first
     * @throws Error if the layerName is not provided or not a non-empty string
     */
    getLayerWithExposureLoggingDisabled: function (user, layerName) {
        return this._enforceServer().getLayerWithExposureLoggingDisabled(user, layerName);
    },
    /**
     * Logs an exposure event for the parameter in the given layer
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} layerName - the name of the layer
     * @param {string} parameterName - the name of the parameter in the layer
     */
    manuallyLogLayerParameterExposure: function (user, layerName, parameterName) {
        this._enforceServer().logLayerParameterExposure(user, layerName, parameterName);
    },
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {StatsigUser} user - the user associated with this event
     * @param {string} eventName - the name of the event (name = Purchase)
     * @param {string | number | null} value - the value associated with the event (value = 10)
     * @param {Record<string, string> | null} metadata - other attributes associated with this event (metadata = {item_name: 'banana', currency: 'USD'})
     * @throws Error if initialize() was not called first
     */
    logEvent: function (user, eventName, value, metadata) {
        if (value === void 0) { value = null; }
        if (metadata === void 0) { metadata = null; }
        this._enforceServer().logEvent(user, eventName, value, metadata);
    },
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {LogEventObject} eventObject - an object containing the event data
     */
    logEventObject: function (eventObject) {
        this._enforceServer().logEventObject(eventObject);
    },
    /**
     * Informs the statsig SDK that the client is closing or shutting down
     * so the SDK can clean up internal state
     */
    shutdown: function () {
        this._enforceServer().shutdown();
        OutputLogger_1["default"].resetLogger();
    },
    /**
     * Returns the initialize values for the given user
     * Can be used to bootstrap a client SDK with up to date values
     * @param user the user to evaluate configurations for
     */
    getClientInitializeResponse: function (user) {
        return this._enforceServer().getClientInitializeResponse(user);
    },
    /**
     * Overrides the given gate with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the gate with the given value for that user only
     */
    overrideGate: function (gateName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideGate(gateName, value, userID);
    },
    /**
     * Overrides the given config or experiment with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the config/experiment with the given value for that user only
     */
    overrideConfig: function (configName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideConfig(configName, value, userID);
    },
    /**
     * Overrides the given layer with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the layer with the given value for that user only
     */
    overrideLayer: function (layerName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideLayer(layerName, value, userID);
    },
    /**
     * Flushes all the events that are currently in the queue to Statsig.
     */
    flush: function () {
        var inst = StatsigInstanceUtils_1["default"].getInstance();
        if (inst == null) {
            return Promise.resolve();
        }
        return inst.flush();
    },
    /**
     * Gets all Experiment names
     *
     * @returns {string[]}
     */
    getExperimentList: function () {
        return this._enforceServer().getExperimentList();
    },
    /**
     * Gets all Feature Gate names
     *
     * @returns {string[]}
     */
    getFeatureGateList: function () {
        return this._enforceServer().getFeatureGateList();
    },
    _enforceServer: function () {
        var instance = StatsigInstanceUtils_1["default"].getInstance();
        if (instance == null) {
            throw new Errors_1.StatsigUninitializedError();
        }
        return instance;
    }
};
exports["default"] = exports.Statsig;
module.exports = __assign({ "default": exports.Statsig }, exports.Statsig);
