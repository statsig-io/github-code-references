"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var node_forge_1 = __importDefault(require("node-forge"));
var ConfigEvaluation_1 = __importDefault(require("./ConfigEvaluation"));
var EvaluationDetails_1 = require("./EvaluationDetails");
var SpecStore_1 = __importDefault(require("./SpecStore"));
var core_1 = require("./utils/core");
var parseUserAgent_1 = __importDefault(require("./utils/parseUserAgent"));
var ip3country = require('ip3country');
var CONDITION_SEGMENT_COUNT = 10 * 1000;
var USER_BUCKET_COUNT = 1000;
var Evaluator = /** @class */ (function () {
    function Evaluator(fetcher, options, diagnostics) {
        this.initialized = false;
        this.store = new SpecStore_1["default"](fetcher, options, diagnostics);
        this.initStrategyForIP3Country = options.initStrategyForIP3Country;
        this.gateOverrides = {};
        this.configOverrides = {};
        this.layerOverrides = {};
    }
    Evaluator.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.store.init()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 6, , 7]);
                        if (!(this.initStrategyForIP3Country === 'lazy')) return [3 /*break*/, 3];
                        setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, ip3country.init()];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 0);
                        return [3 /*break*/, 5];
                    case 3:
                        if (!(this.initStrategyForIP3Country !== 'none')) return [3 /*break*/, 5];
                        return [4 /*yield*/, ip3country.init()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        err_1 = _a.sent();
                        return [3 /*break*/, 7];
                    case 7:
                        this.initialized = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    Evaluator.prototype.overrideGate = function (gateName, value, userID) {
        var _a;
        if (userID === void 0) { userID = null; }
        var overrides = (_a = this.gateOverrides[gateName]) !== null && _a !== void 0 ? _a : {};
        overrides[userID == null ? '' : userID] = value;
        this.gateOverrides[gateName] = overrides;
    };
    Evaluator.prototype.overrideConfig = function (configName, value, userID) {
        var _a;
        if (userID === void 0) { userID = ''; }
        var overrides = (_a = this.configOverrides[configName]) !== null && _a !== void 0 ? _a : {};
        overrides[userID == null ? '' : userID] = value;
        this.configOverrides[configName] = overrides;
    };
    Evaluator.prototype.overrideLayer = function (layerName, value, userID) {
        var _a;
        if (userID === void 0) { userID = ''; }
        var overrides = (_a = this.layerOverrides[layerName]) !== null && _a !== void 0 ? _a : {};
        overrides[userID == null ? '' : userID] = value;
        this.layerOverrides[layerName] = overrides;
    };
    Evaluator.prototype.checkGate = function (user, gateName) {
        var override = this.lookupGateOverride(user, gateName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        return this._evalConfig(user, this.store.getGate(gateName));
    };
    Evaluator.prototype.getConfig = function (user, configName) {
        var override = this.lookupConfigOverride(user, configName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        return this._evalConfig(user, this.store.getConfig(configName));
    };
    Evaluator.prototype.getLayer = function (user, layerName) {
        var override = this.lookupLayerOverride(user, layerName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        return this._evalConfig(user, this.store.getLayer(layerName));
    };
    Evaluator.prototype.getClientInitializeResponse = function (user) {
        var _this = this;
        if (!this.store.isServingChecks()) {
            return null;
        }
        var gates = Object.entries(this.store.getAllGates())
            .map(function (_a) {
            var gate = _a[0], spec = _a[1];
            if ((spec === null || spec === void 0 ? void 0 : spec.entity) === 'segment' || (spec === null || spec === void 0 ? void 0 : spec.entity) === 'holdout') {
                return null;
            }
            var res = _this._eval(user, spec);
            return {
                name: getHashedName(gate),
                value: res.fetch_from_server ? false : res.value,
                rule_id: res.rule_id,
                secondary_exposures: _this._cleanExposures(res.secondary_exposures)
            };
        })
            .filter(function (item) { return item !== null; });
        var configs = Object.entries(this.store.getAllConfigs()).map(function (_a) {
            var _b;
            var config = _a[0], spec = _a[1];
            var res = _this._eval(user, spec);
            var format = _this._specToInitializeResponse(spec, res);
            if (spec.entity !== 'dynamic_config' && spec.entity !== 'autotune') {
                format.is_user_in_experiment = _this._isUserAllocatedToExperiment(user, spec);
                format.is_experiment_active = _this._isExperimentActive(spec);
                if (spec.hasSharedParams) {
                    format.is_in_layer = true;
                    format.explicit_parameters = (_b = spec.explicitParameters) !== null && _b !== void 0 ? _b : [];
                    var layerValue = {};
                    var layerName = _this.store.getExperimentLayer(spec.name);
                    if (layerName != null) {
                        var layer = _this.store.getLayer(layerName);
                        if (layer != null) {
                            layerValue = layer.defaultValue;
                        }
                    }
                    format.value = __assign(__assign({}, layerValue), format.value);
                }
            }
            return format;
        });
        var layers = Object.entries(this.store.getAllLayers()).map(function (_a) {
            var _b, _c, _d;
            var layer = _a[0], spec = _a[1];
            var res = _this._eval(user, spec);
            var format = _this._specToInitializeResponse(spec, res);
            format.explicit_parameters = (_b = spec.explicitParameters) !== null && _b !== void 0 ? _b : [];
            if (res.config_delegate != null && res.config_delegate !== '') {
                var delegateSpec = _this.store.getConfig(res.config_delegate);
                format.allocated_experiment_name = getHashedName(res.config_delegate);
                format.is_experiment_active = _this._isExperimentActive(delegateSpec);
                format.is_user_in_experiment = _this._isUserAllocatedToExperiment(user, delegateSpec);
                format.explicit_parameters = (_c = delegateSpec === null || delegateSpec === void 0 ? void 0 : delegateSpec.explicitParameters) !== null && _c !== void 0 ? _c : [];
            }
            format.undelegated_secondary_exposures = _this._cleanExposures((_d = res.undelegated_secondary_exposures) !== null && _d !== void 0 ? _d : []);
            return format;
        });
        var evaluatedKeys = {};
        if (user.userID) {
            evaluatedKeys['userID'] = user.userID;
        }
        if (user.customIDs && Object.keys(user.customIDs).length > 0) {
            evaluatedKeys['customIDs'] = user.customIDs;
        }
        return {
            feature_gates: Object.assign.apply(Object, __spreadArray([{}], gates.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            dynamic_configs: Object.assign.apply(Object, __spreadArray([{}], configs.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            layer_configs: Object.assign.apply(Object, __spreadArray([{}], layers.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            sdkParams: {},
            has_updates: true,
            generator: 'statsig-node-sdk',
            time: 0,
            evaluated_keys: evaluatedKeys
        };
    };
    Evaluator.prototype.resetSyncTimerIfExited = function () {
        return this.store.resetSyncTimerIfExited();
    };
    Evaluator.prototype.getExperimentList = function () {
        var configs = this.store.getAllConfigs();
        var list = [];
        for (var configName in configs) {
            var config = configs[configName];
            if (config.entity === 'experiment') {
                list.push(configName);
            }
        }
        return list;
    };
    Evaluator.prototype.getFeatureGateList = function () {
        var gates = this.store.getAllGates();
        var list = [];
        for (var gateName in gates) {
            var gate = gates[gateName];
            if (gate.entity === 'feature_gate') {
                list.push(gateName);
            }
        }
        return list;
    };
    Evaluator.prototype.lookupGateOverride = function (user, gateName) {
        var overrides = this.gateOverrides[gateName];
        if (overrides == null) {
            return null;
        }
        if (user.userID != null) {
            // check for a user level override
            var userOverride = overrides[user.userID];
            if (userOverride != null) {
                return new ConfigEvaluation_1["default"](userOverride, 'override');
            }
        }
        // check if there is a global override
        var allOverride = overrides[''];
        if (allOverride != null) {
            return new ConfigEvaluation_1["default"](allOverride, 'override');
        }
        return null;
    };
    Evaluator.prototype.lookupConfigOverride = function (user, configName) {
        var overrides = this.configOverrides[configName];
        return this.lookupConfigBasedOverride(user, overrides);
    };
    Evaluator.prototype.lookupLayerOverride = function (user, layerName) {
        var overrides = this.layerOverrides[layerName];
        return this.lookupConfigBasedOverride(user, overrides);
    };
    Evaluator.prototype.lookupConfigBasedOverride = function (user, overrides) {
        if (overrides == null) {
            return null;
        }
        if (user.userID != null) {
            // check for a user level override
            var userOverride = overrides[user.userID];
            if (userOverride != null) {
                return new ConfigEvaluation_1["default"](true, 'override', null, [], userOverride);
            }
        }
        // check if there is a global override
        var allOverride = overrides[''];
        if (allOverride != null) {
            return new ConfigEvaluation_1["default"](true, 'override', null, [], allOverride);
        }
        return null;
    };
    Evaluator.prototype._specToInitializeResponse = function (spec, res) {
        var output = {
            name: getHashedName(spec.name),
            value: res.fetch_from_server ? {} : res.json_value,
            group: res.rule_id,
            rule_id: res.rule_id,
            is_device_based: spec.idType != null && spec.idType.toLowerCase() === 'stableid',
            secondary_exposures: this._cleanExposures(res.secondary_exposures)
        };
        if (res.explicit_parameters) {
            output.explicit_parameters = res.explicit_parameters;
        }
        return output;
    };
    Evaluator.prototype._cleanExposures = function (exposures) {
        var seen = {};
        return exposures
            .map(function (exposure) {
            var key = "".concat(exposure.gate, "|").concat(exposure.gateValue, "|").concat(exposure.ruleID);
            if (seen[key]) {
                return null;
            }
            seen[key] = true;
            return exposure;
        })
            .filter(core_1.notEmpty);
    };
    Evaluator.prototype.shutdown = function () {
        this.store.shutdown();
    };
    Evaluator.prototype._evalConfig = function (user, config) {
        if (!config) {
            return new ConfigEvaluation_1["default"](false, '', null).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'Unrecognized'));
        }
        var evaulation = this._eval(user, config);
        return evaulation.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), this.store.getInitReason()));
    };
    Evaluator.prototype._eval = function (user, config) {
        if (!config.enabled) {
            return new ConfigEvaluation_1["default"](false, 'disabled', null, [], config.defaultValue);
        }
        var secondary_exposures = [];
        for (var i = 0; i < config.rules.length; i++) {
            var rule = config.rules[i];
            var ruleResult = this._evalRule(user, rule);
            if (ruleResult.fetch_from_server) {
                return ConfigEvaluation_1["default"].fetchFromServer();
            }
            secondary_exposures = secondary_exposures.concat(ruleResult.secondary_exposures);
            if (ruleResult.value === true) {
                var delegatedResult = this._evalDelegate(user, rule, secondary_exposures);
                if (delegatedResult) {
                    return delegatedResult;
                }
                var pass = this._evalPassPercent(user, rule, config);
                var evaluation = new ConfigEvaluation_1["default"](pass, ruleResult.rule_id, ruleResult.group_name, secondary_exposures, pass
                    ? ruleResult.json_value
                    : config.defaultValue, config.explicitParameters, ruleResult.config_delegate);
                evaluation.setIsExperimentGroup(ruleResult.is_experiment_group);
                return evaluation;
            }
        }
        return new ConfigEvaluation_1["default"](false, 'default', null, secondary_exposures, config.defaultValue, config.explicitParameters);
    };
    Evaluator.prototype._evalDelegate = function (user, rule, exposures) {
        if (rule.configDelegate == null) {
            return null;
        }
        var config = this.store.getConfig(rule.configDelegate);
        if (!config) {
            return null;
        }
        var delegatedResult = this._eval(user, config);
        delegatedResult.config_delegate = rule.configDelegate;
        delegatedResult.undelegated_secondary_exposures = exposures;
        delegatedResult.explicit_parameters = config.explicitParameters;
        delegatedResult.secondary_exposures = exposures.concat(delegatedResult.secondary_exposures);
        return delegatedResult;
    };
    Evaluator.prototype._evalPassPercent = function (user, rule, config) {
        var _a, _b;
        var hash = computeUserHash(config.salt +
            '.' +
            ((_a = rule.salt) !== null && _a !== void 0 ? _a : rule.id) +
            '.' +
            ((_b = this._getUnitID(user, rule.idType)) !== null && _b !== void 0 ? _b : ''));
        return (Number(hash % BigInt(CONDITION_SEGMENT_COUNT)) < rule.passPercentage * 100);
    };
    Evaluator.prototype._getUnitID = function (user, idType) {
        var _a;
        if (typeof idType === 'string' && idType.toLowerCase() !== 'userid') {
            var unitID = (_a = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a === void 0 ? void 0 : _a[idType];
            if (unitID !== undefined) {
                return unitID;
            }
            return getParameterCaseInsensitive(user === null || user === void 0 ? void 0 : user.customIDs, idType);
        }
        return user === null || user === void 0 ? void 0 : user.userID;
    };
    Evaluator.prototype._evalRule = function (user, rule) {
        var _a;
        var secondaryExposures = [];
        var pass = true;
        for (var _i = 0, _b = rule.conditions; _i < _b.length; _i++) {
            var condition = _b[_i];
            var result = this._evalCondition(user, condition);
            if (result.fetchFromServer) {
                return ConfigEvaluation_1["default"].fetchFromServer();
            }
            if (!result.passes) {
                pass = false;
            }
            if (result.exposures) {
                secondaryExposures = secondaryExposures.concat(result.exposures);
            }
        }
        var evaluation = new ConfigEvaluation_1["default"](pass, rule.id, rule.groupName, secondaryExposures, rule.returnValue);
        evaluation.setIsExperimentGroup((_a = rule.isExperimentGroup) !== null && _a !== void 0 ? _a : false);
        return evaluation;
    };
    Evaluator.prototype._evalCondition = function (user, condition) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var value = null;
        var field = condition.field;
        var target = condition.targetValue;
        var idType = condition.idType;
        switch (condition.type.toLowerCase()) {
            case 'public':
                return { passes: true };
            case 'fail_gate':
            case 'pass_gate':
                var gateResult = this.checkGate(user, target);
                if (gateResult === null || gateResult === void 0 ? void 0 : gateResult.fetch_from_server) {
                    return { passes: false, fetchFromServer: true };
                }
                value = gateResult === null || gateResult === void 0 ? void 0 : gateResult.value;
                var allExposures = (_a = gateResult === null || gateResult === void 0 ? void 0 : gateResult.secondary_exposures) !== null && _a !== void 0 ? _a : [];
                allExposures.push({
                    gate: String(target),
                    gateValue: String(value),
                    ruleID: (_b = gateResult === null || gateResult === void 0 ? void 0 : gateResult.rule_id) !== null && _b !== void 0 ? _b : ''
                });
                return {
                    passes: condition.type.toLowerCase() === 'fail_gate' ? !value : !!value,
                    exposures: allExposures
                };
            case 'ip_based':
                // this would apply to things like 'country', 'region', etc.
                value = (_c = getFromUser(user, field)) !== null && _c !== void 0 ? _c : this.getFromIP(user, field);
                break;
            case 'ua_based':
                // this would apply to things like 'os', 'browser', etc.
                value = (_d = getFromUser(user, field)) !== null && _d !== void 0 ? _d : getFromUserAgent(user, field);
                break;
            case 'user_field':
                value = getFromUser(user, field);
                break;
            case 'environment_field':
                value = getFromEnvironment(user, field);
                break;
            case 'current_time':
                value = Date.now();
                break;
            case 'user_bucket':
                var salt = (_e = condition.additionalValues) === null || _e === void 0 ? void 0 : _e.salt;
                var userHash = computeUserHash((_f = salt + '.' + this._getUnitID(user, idType)) !== null && _f !== void 0 ? _f : '');
                value = Number(userHash % BigInt(USER_BUCKET_COUNT));
                break;
            case 'unit_id':
                value = this._getUnitID(user, idType);
                break;
            default:
                return { passes: false, fetchFromServer: true };
        }
        var op = (_g = condition.operator) === null || _g === void 0 ? void 0 : _g.toLowerCase();
        var evalResult = false;
        switch (op) {
            // numerical
            case 'gt':
                evalResult = numberCompare(function (a, b) { return a > b; })(value, target);
                break;
            case 'gte':
                evalResult = numberCompare(function (a, b) { return a >= b; })(value, target);
                break;
            case 'lt':
                evalResult = numberCompare(function (a, b) { return a < b; })(value, target);
                break;
            case 'lte':
                evalResult = numberCompare(function (a, b) { return a <= b; })(value, target);
                break;
            // version
            case 'version_gt':
                evalResult = versionCompareHelper(function (result) { return result > 0; })(value, target);
                break;
            case 'version_gte':
                evalResult = versionCompareHelper(function (result) { return result >= 0; })(value, target);
                break;
            case 'version_lt':
                evalResult = versionCompareHelper(function (result) { return result < 0; })(value, target);
                break;
            case 'version_lte':
                evalResult = versionCompareHelper(function (result) { return result <= 0; })(value, target);
                break;
            case 'version_eq':
                evalResult = versionCompareHelper(function (result) { return result === 0; })(value, target);
                break;
            case 'version_neq':
                evalResult = versionCompareHelper(function (result) { return result !== 0; })(value, target);
                break;
            // array
            case 'any':
                evalResult = arrayAny(value, target, stringCompare(true, function (a, b) { return a === b; }));
                break;
            case 'none':
                evalResult = !arrayAny(value, target, stringCompare(true, function (a, b) { return a === b; }));
                break;
            case 'any_case_sensitive':
                evalResult = arrayAny(value, target, stringCompare(false, function (a, b) { return a === b; }));
                break;
            case 'none_case_sensitive':
                evalResult = !arrayAny(value, target, stringCompare(false, function (a, b) { return a === b; }));
                break;
            // string
            case 'str_starts_with_any':
                evalResult = arrayAny(value, target, stringCompare(true, function (a, b) { return a.startsWith(b); }));
                break;
            case 'str_ends_with_any':
                evalResult = arrayAny(value, target, stringCompare(true, function (a, b) { return a.endsWith(b); }));
                break;
            case 'str_contains_any':
                evalResult = arrayAny(value, target, stringCompare(true, function (a, b) { return a.includes(b); }));
                break;
            case 'str_contains_none':
                evalResult = !arrayAny(value, target, stringCompare(true, function (a, b) { return a.includes(b); }));
                break;
            case 'str_matches':
                try {
                    if (String(value).length < 1000) {
                        evalResult = new RegExp(target).test(String(value));
                    }
                    else {
                        evalResult = false;
                    }
                }
                catch (e) {
                    evalResult = false;
                }
                break;
            // strictly equals
            case 'eq':
                evalResult = value == target;
                break;
            case 'neq':
                evalResult = value != target;
                break;
            // dates
            case 'before':
                evalResult = dateCompare(function (a, b) { return a < b; })(value, target);
                break;
            case 'after':
                evalResult = dateCompare(function (a, b) { return a > b; })(value, target);
                break;
            case 'on':
                evalResult = dateCompare(function (a, b) {
                    a === null || a === void 0 ? void 0 : a.setHours(0, 0, 0, 0);
                    b === null || b === void 0 ? void 0 : b.setHours(0, 0, 0, 0);
                    return (a === null || a === void 0 ? void 0 : a.getTime()) === (b === null || b === void 0 ? void 0 : b.getTime());
                })(value, target);
                break;
            case 'in_segment_list':
            case 'not_in_segment_list': {
                var list = (_h = this.store.getIDList(target)) === null || _h === void 0 ? void 0 : _h.ids;
                value = hashUnitIDForIDList(value);
                var inList = typeof list === 'object' && list[value] === true;
                evalResult = op === 'in_segment_list' ? inList : !inList;
                break;
            }
            default:
                return { passes: false, fetchFromServer: true };
        }
        return { passes: evalResult };
    };
    Evaluator.prototype._isExperimentActive = function (experimentConfig) {
        if (experimentConfig == null) {
            return false;
        }
        return experimentConfig.isActive === true;
    };
    Evaluator.prototype._isUserAllocatedToExperiment = function (user, experimentConfig) {
        if (experimentConfig == null) {
            return false;
        }
        var evalResult = this._eval(user, experimentConfig);
        return evalResult.is_experiment_group;
    };
    Evaluator.prototype.getFromIP = function (user, field) {
        var ip = getFromUser(user, 'ip');
        if (ip == null || field !== 'country') {
            return null;
        }
        return this.ip2country(ip);
    };
    Evaluator.prototype.ip2country = function (ip) {
        if (!this.initialized) {
            return null;
        }
        try {
            if (typeof ip === 'string') {
                return ip3country.lookupStr(ip);
            }
            else if (typeof ip === 'number') {
                return ip3country.lookupNumeric(ip);
            }
        }
        catch (e) {
            // TODO: log
        }
        return null;
    };
    return Evaluator;
}());
exports["default"] = Evaluator;
var hashLookupTable = new Map();
function computeUserHash(userHash) {
    var existingHash = hashLookupTable.get(userHash);
    if (existingHash) {
        return existingHash;
    }
    var md = node_forge_1["default"].md.sha256.create();
    md.update(userHash);
    var hash = BigInt("0x".concat(md.digest().toHex().substring(0, 16)));
    if (hashLookupTable.size > 100000) {
        hashLookupTable.clear();
    }
    hashLookupTable.set(userHash, hash);
    return hash;
}
function getHashedName(name) {
    var md = node_forge_1["default"].md.sha256.create();
    md.update(name);
    return node_forge_1["default"].util.encode64(md.digest().getBytes());
}
function hashUnitIDForIDList(unitID) {
    if (typeof unitID !== 'string' || unitID == null) {
        return '';
    }
    return getHashedName(unitID).substr(0, 8);
}
function getFromUser(user, field) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (typeof user !== 'object') {
        return null;
    }
    var indexableUser = user;
    return ((_h = (_f = (_d = (_b = (_a = indexableUser[field]) !== null && _a !== void 0 ? _a : indexableUser[field.toLowerCase()]) !== null && _b !== void 0 ? _b : (_c = user === null || user === void 0 ? void 0 : user.custom) === null || _c === void 0 ? void 0 : _c[field]) !== null && _d !== void 0 ? _d : (_e = user === null || user === void 0 ? void 0 : user.custom) === null || _e === void 0 ? void 0 : _e[field.toLowerCase()]) !== null && _f !== void 0 ? _f : (_g = user === null || user === void 0 ? void 0 : user.privateAttributes) === null || _g === void 0 ? void 0 : _g[field]) !== null && _h !== void 0 ? _h : (_j = user === null || user === void 0 ? void 0 : user.privateAttributes) === null || _j === void 0 ? void 0 : _j[field.toLowerCase()]);
}
function getFromUserAgent(user, field) {
    var _a, _b, _c, _d;
    var ua = getFromUser(user, 'userAgent');
    if (ua == null) {
        return null;
    }
    if (typeof ua !== 'string' || ua.length > 1000) {
        return null;
    }
    var res = (0, parseUserAgent_1["default"])(ua);
    switch (field.toLowerCase()) {
        case 'os_name':
        case 'osname':
            return (_a = res.os.name) !== null && _a !== void 0 ? _a : null;
        case 'os_version':
        case 'osversion':
            return (_b = res.os.version) !== null && _b !== void 0 ? _b : null;
        case 'browser_name':
        case 'browsername':
            return (_c = res.browser.name) !== null && _c !== void 0 ? _c : null;
        case 'browser_version':
        case 'browserversion':
            return (_d = res.browser.version) !== null && _d !== void 0 ? _d : null;
        default:
            return null;
    }
}
function getFromEnvironment(user, field) {
    return getParameterCaseInsensitive(user === null || user === void 0 ? void 0 : user.statsigEnvironment, field);
}
function getParameterCaseInsensitive(object, key) {
    if (object == null) {
        return undefined;
    }
    var asLowercase = key.toLowerCase();
    var keyMatch = Object.keys(object).find(function (k) { return k.toLowerCase() === asLowercase; });
    if (keyMatch === undefined) {
        return undefined;
    }
    return object[keyMatch];
}
function numberCompare(fn) {
    return function (a, b) {
        if (a == null || b == null) {
            return false;
        }
        var numA = Number(a);
        var numB = Number(b);
        if (isNaN(numA) || isNaN(numB)) {
            return false;
        }
        return fn(numA, numB);
    };
}
function versionCompareHelper(fn) {
    return function (a, b) {
        var comparison = versionCompare(a, b);
        if (comparison == null) {
            return false;
        }
        return fn(comparison);
    };
}
// Compare two version strings without the extensions.
// returns -1, 0, or 1 if first is smaller than, equal to, or larger than second.
// returns false if any of the version strings is not valid.
function versionCompare(first, second) {
    if (typeof first !== 'string' || typeof second !== 'string') {
        return null;
    }
    var version1 = removeVersionExtension(first);
    var version2 = removeVersionExtension(second);
    if (version1.length === 0 || version2.length === 0) {
        return null;
    }
    var parts1 = version1.split('.');
    var parts2 = version2.split('.');
    for (var i = 0; i < Math.max(parts1.length, parts2.length); i++) {
        if (parts1[i] === undefined) {
            parts1[i] = '0';
        }
        if (parts2[i] === undefined) {
            parts2[i] = '0';
        }
        var n1 = Number(parts1[i]);
        var n2 = Number(parts2[i]);
        if (typeof n1 !== 'number' ||
            typeof n2 !== 'number' ||
            isNaN(n1) ||
            isNaN(n2)) {
            return null;
        }
        if (n1 < n2) {
            return -1;
        }
        else if (n1 > n2) {
            return 1;
        }
    }
    return 0;
}
function removeVersionExtension(version) {
    var hyphenIndex = version.indexOf('-');
    if (hyphenIndex >= 0) {
        return version.substr(0, hyphenIndex);
    }
    return version;
}
function stringCompare(ignoreCase, fn) {
    return function (a, b) {
        if (a == null || b == null) {
            return false;
        }
        return ignoreCase
            ? fn(String(a).toLowerCase(), String(b).toLowerCase())
            : fn(String(a), String(b));
    };
}
function dateCompare(fn) {
    return function (a, b) {
        if (a == null || b == null) {
            return false;
        }
        try {
            // Try to parse into date as a string first, if not, try unixtime
            var dateA = new Date(a);
            if (isNaN(dateA.getTime())) {
                dateA = new Date(Number(a));
            }
            var dateB = new Date(b);
            if (isNaN(dateB.getTime())) {
                dateB = new Date(Number(b));
            }
            return (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime()) && fn(dateA, dateB));
        }
        catch (e) {
            // malformatted input, returning false
            return false;
        }
    };
}
function arrayAny(value, array, fn) {
    if (!Array.isArray(array)) {
        return false;
    }
    for (var i = 0; i < array.length; i++) {
        if (fn(value, array[i])) {
            return true;
        }
    }
    return false;
}
