"use strict";
exports.__esModule = true;
var Dispatcher = /** @class */ (function () {
    function Dispatcher(drainIntervalms) {
        if (drainIntervalms === void 0) { drainIntervalms = 200; }
        this.queue = [];
        this.drainInterval = drainIntervalms;
        this.drainTimer = this._scheduleDrain();
    }
    Dispatcher.prototype.enqueue = function (promise, timeoutms) {
        var entry = {
            expiry: Date.now() + timeoutms,
            promise: promise,
            taskCompleted: false,
            resolver: null,
            rejector: null
        };
        var dispatcherPromise = new Promise(function (res, rej) {
            entry.resolver = res;
            entry.rejector = rej;
        });
        this.queue.push(entry);
        var markCompleted = (function (e) {
            e.taskCompleted = true;
        }).bind(this);
        promise.then(function (result) {
            markCompleted(entry);
            if (entry.resolver != null) {
                entry.resolver(result);
            }
            return result;
        }, function (err) {
            markCompleted(entry);
            if (entry.rejector != null) {
                entry.rejector();
            }
            return err;
        });
        return dispatcherPromise;
    };
    Dispatcher.prototype._scheduleDrain = function () {
        var drain = setTimeout(this._drainQueue.bind(this), this.drainInterval);
        if (drain.unref) {
            drain.unref();
        }
        return drain;
    };
    Dispatcher.prototype._drainQueue = function () {
        var _this = this;
        var oldQueue = this.queue;
        this.queue = [];
        var now = Date.now();
        oldQueue.forEach(function (entry) {
            if (!entry.taskCompleted) {
                if (entry.expiry > now) {
                    _this.queue.push(entry);
                }
                else {
                    if (entry.rejector != null) {
                        entry.rejector('time_out');
                    }
                }
            }
        }, this);
        this.drainTimer = this._scheduleDrain();
    };
    Dispatcher.prototype.shutdown = function () {
        if (this.drainTimer != null) {
            clearTimeout(this.drainTimer);
        }
    };
    return Dispatcher;
}());
exports["default"] = Dispatcher;
